<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Qwen3-TTS WebUI</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="icon" type="image/x-icon" href="/static/qwentts.ico">
    <style>
        :root {
            --primary: #000000;
            --secondary: #ffffff;
            --accent: #ff6b35;
            --accent-hover: #ff8c5a;
            --surface: #f5f5f5;
            --border: #000000;
            --text-primary: #000000;
            --text-secondary: #555555;
            --shadow: rgba(0, 0, 0, 0.9);
            --shadow-offset: 4px;
            --radius: 0px;
        }

        [data-theme="dark"] {
            --primary: #ffffff;
            --secondary: #1a1a1a;
            --accent: #ff6b35;
            --accent-hover: #ff8c5a;
            --surface: #0d0d0d;
            --border: #ffffff;
            --text-primary: #ffffff;
            --text-secondary: #aaaaaa;
            --shadow: rgba(255, 255, 255, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--surface);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 24px;
            line-height: 1.6;
            transition: background 0.3s ease, color 0.3s ease;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Theme Toggle */
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }

        .theme-toggle button {
            background: var(--secondary);
            color: var(--text-primary);
            border: 3px solid var(--border);
            padding: 12px 16px;
            cursor: pointer;
            font-size: 18px;
            font-weight: 700;
            box-shadow: var(--shadow-offset) var(--shadow-offset) 0 var(--shadow);
            transition: all 0.1s ease;
        }

        .theme-toggle button:hover {
            transform: translate(-2px, -2px);
            box-shadow: 6px 6px 0 var(--shadow);
        }

        .theme-toggle button:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 var(--shadow);
        }

        .header {
            text-align: center;
            margin-bottom: 48px;
        }

        .logo {
            display: inline-flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .logo-icon {
            width: 48px;
            height: 48px;
            background: var(--primary);
            border: 3px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            color: var(--secondary);
            box-shadow: var(--shadow-offset) var(--shadow-offset) 0 var(--shadow);
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 900;
            margin-bottom: 8px;
            letter-spacing: -0.025em;
            text-transform: uppercase;
        }

        .header p {
            font-size: 1.125rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .tabs-container {
            background: var(--secondary);
            border: 3px solid var(--border);
            margin-bottom: 24px;
            box-shadow: var(--shadow-offset) var(--shadow-offset) 0 var(--shadow);
        }

        .tabs {
            display: flex;
        }

        .tab {
            padding: 16px 32px;
            cursor: pointer;
            transition: all 0.1s ease;
            font-weight: 700;
            border-bottom: 4px solid transparent;
            position: relative;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tab.active {
            color: var(--secondary);
            background: var(--accent);
            border-bottom-color: var(--primary);
        }

        .tab:hover:not(.active) {
            background: var(--surface);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .card {
            background: var(--secondary);
            border: 3px solid var(--border);
            padding: 32px;
            margin-bottom: 24px;
            box-shadow: var(--shadow-offset) var(--shadow-offset) 0 var(--shadow);
            transition: all 0.2s ease;
        }

        .card h3 {
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 16px;
        }

        .form-group {
            margin-bottom: 24px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 700;
            color: var(--text-primary);
            text-transform: uppercase;
            font-size: 14px;
            letter-spacing: 0.5px;
        }

        input, textarea, select {
            width: 100%;
            padding: 12px 16px;
            border: 3px solid var(--border);
            border-radius: var(--radius);
            font-size: 16px;
            font-family: inherit;
            background: var(--surface);
            color: var(--text-primary);
            transition: all 0.1s ease;
            font-weight: 500;
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 4px 4px 0 var(--accent);
            transform: translate(-2px, -2px);
        }

        input::placeholder, textarea::placeholder {
            color: var(--text-secondary);
            font-weight: 400;
        }

        textarea {
            min-height: 120px;
            resize: vertical;
        }

        select {
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 16px;
            padding-right: 44px;
        }

        [data-theme="dark"] select {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
        }

        .input-with-button {
            display: flex;
            gap: 12px;
        }

        .input-with-button input {
            flex: 1;
        }

        .input-with-button .btn {
            flex-shrink: 0;
        }

        .audio-upload-tabs {
            display: flex;
            background: var(--surface);
            border: 3px solid var(--border);
            margin-bottom: 24px;
        }

        .audio-upload-tabs .tab {
            padding: 12px 24px;
            flex: 1;
            text-align: center;
            border-bottom: none;
            border-right: 3px solid var(--border);
        }

        .audio-upload-tabs .tab:last-child {
            border-right: none;
        }

        .audio-upload-tabs .tab.active {
            background: var(--primary);
            color: var(--secondary);
        }

        .btn {
            background: var(--primary);
            color: var(--secondary);
            border: 3px solid var(--border);
            padding: 14px 28px;
            border-radius: var(--radius);
            cursor: pointer;
            font-size: 16px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.1s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            box-shadow: var(--shadow-offset) var(--shadow-offset) 0 var(--shadow);
        }

        .btn:hover {
            transform: translate(-2px, -2px);
            box-shadow: 6px 6px 0 var(--shadow);
        }

        .btn:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 var(--shadow);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
            border-color: #000000;
        }

        [data-theme="dark"] .btn-danger {
            border-color: #ffffff;
        }

        .btn-danger:hover {
            background: #ff4d5e;
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: var(--surface);
            border: 3px solid var(--border);
            overflow: hidden;
            margin: 16px 0;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.3s ease;
        }

        .audio-player {
            width: 100%;
            margin: 16px 0;
            border-radius: var(--radius);
        }

        .hidden {
            display: none;
        }

        .error {
            background: #fee2e2;
            color: #991b1b;
            border: 3px solid #991b1b;
            padding: 16px;
            border-radius: var(--radius);
            margin: 16px 0;
            box-shadow: var(--shadow-offset) var(--shadow-offset) 0 #991b1b;
            font-weight: 600;
        }

        [data-theme="dark"] .error {
            background: #3d1515;
            color: #ff8a8a;
            border-color: #ff8a8a;
            box-shadow: var(--shadow-offset) var(--shadow-offset) 0 rgba(255, 138, 138, 0.3);
        }

        .result-audio {
            width: 100%;
            margin: 16px 0;
            border-radius: var(--radius);
        }

        .generated-audio-item {
            background: var(--secondary);
            border: 3px solid var(--border);
            padding: 24px;
            margin-bottom: 16px;
            border-radius: var(--radius);
            transition: all 0.1s ease;
            box-shadow: var(--shadow-offset) var(--shadow-offset) 0 var(--shadow);
        }

        .generated-audio-item:hover {
            transform: translate(-2px, -2px);
            box-shadow: 6px 6px 0 var(--shadow);
        }

        .generated-audio-title {
            font-weight: 700;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .generated-audio-meta {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 12px;
            font-weight: 500;
        }

        .generated-audio-controls {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-top: 16px;
        }

        .generated-audio-controls audio {
            flex: 1;
        }

        .generated-audio-controls .btn {
            flex-shrink: 0;
        }

        /* Recording section neobrutalist style */
        .recording-area {
            text-align: center;
            padding: 24px;
            border: 3px dashed var(--border);
            margin-bottom: 15px;
            background: var(--surface);
        }

        /* Toast notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        .toast {
            background: #dc3545;
            color: white;
            padding: 16px 20px;
            border: 3px solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow-offset) var(--shadow-offset) 0 var(--shadow);
            font-weight: 600;
            max-width: 400px;
            pointer-events: auto;
            transform: translateX(-120%);
            animation: slideIn 0.3s ease forwards;
        }

        .toast.slide-out {
            animation: slideOut 0.3s ease forwards;
        }

        @keyframes slideIn {
            from {
                transform: translateX(-120%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(-120%);
                opacity: 0;
            }
        }

        .toast-success {
            background: #28a745;
        }

        .toast-error {
            background: #dc3545;
        }

        [data-theme="dark"] .toast {
            box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.5);
        }

        /* Links section */
        .links-section {
            text-align: center;
            margin-top: 48px;
        }

        .links-section a {
            color: var(--text-primary);
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 12px 24px;
            border: 3px solid var(--border);
            background: var(--secondary);
            transition: all 0.1s ease;
            font-weight: 600;
            box-shadow: var(--shadow-offset) var(--shadow-offset) 0 var(--shadow);
        }

        .links-section a:hover {
            transform: translate(-2px, -2px);
            box-shadow: 6px 6px 0 var(--shadow);
        }

        .links-section a:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 var(--shadow);
        }

        /* Multi-speaker segment styles */
        .speaker-segment {
            background: var(--surface);
            border: 3px solid var(--border);
            padding: 20px;
            margin-bottom: 16px;
            position: relative;
        }

        .speaker-segment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .speaker-segment-title {
            font-weight: 700;
            text-transform: uppercase;
            font-size: 14px;
            letter-spacing: 0.5px;
        }

        .speaker-segment-remove {
            background: #dc3545;
            color: white;
            border: 2px solid var(--border);
            padding: 6px 12px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
        }

        .speaker-segment-remove:hover {
            background: #ff4d5e;
        }

        .speaker-segment .form-group {
            margin-bottom: 16px;
        }

        .speaker-segment .form-group:last-child {
            margin-bottom: 0;
        }

        .segment-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        @media (max-width: 768px) {
            .segment-row {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 16px;
            }
            
            .card {
                padding: 24px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .generated-audio-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .generated-audio-controls .btn {
                justify-content: center;
            }

            .theme-toggle {
                position: static;
                text-align: right;
                margin-bottom: 16px;
            }

            .input-with-button {
                flex-direction: column;
            }

            .input-with-button .btn {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <!-- Toast notification container -->
    <div id="toast-container" class="toast-container"></div>

    <div class="theme-toggle">
        <button onclick="toggleTheme()" id="theme-btn" title="Toggle dark mode">
            <span id="theme-icon">&#9790;</span>
        </button>
    </div>
    <div class="container">
        <div class="header">
            <div class="logo">

                <div>
                    <h1>Qwen TTS</h1>
                    <p>Generate speech using AI - upload a reference audio and create new voice synthesis</p>
                </div>
            </div>
        </div>

        <div class="tabs-container">
            <div class="tabs">
                <div class="tab active" onclick="switchTab('existing')">Use Existing Reference</div>
                <div class="tab" onclick="switchTab('upload')">Upload New Reference</div>
                <div class="tab" onclick="switchTab('multispeaker')">Multi-Speaker</div>
            </div>
        </div>
        
        <div class="card">

            <!-- Existing Reference Tab -->
            <div id="existing-tab" class="tab-content active">
                <div class="form-group">
                    <label for="reference-select">Select Reference Audio:</label>
                    <select id="reference-select" onchange="selectReferenceFromDropdown()">
                        <option value="">-- Choose a reference audio --</option>
                    </select>
                </div>
                
                <div class="form-group" id="reference-preview" style="display: none;">
                    <label>Preview:</label>
                    <audio controls class="audio-player" id="preview-audio">
                        Your browser does not support the audio element.
                    </audio>
                </div>

                <div class="form-group" id="reference-rename" style="display: none;">
                    <label for="reference-name-input">Reference Name:</label>
                    <div class="input-with-button">
                        <input type="text" id="reference-name-input" placeholder="Enter a custom name for this reference...">
                        <button class="btn" onclick="renameReference()">Rename</button>
                    </div>
                </div>

                <div class="form-group">
                    <label for="text-existing">Text to Generate:</label>
                    <textarea id="text-existing" placeholder="Enter the text you want to generate in the cloned voice...">Hello, this is a test of the voice cloning system. How does it sound?</textarea>
                </div>

                <div class="form-group">
                    <label for="language-existing">Language:</label>
                    <select id="language-existing">
                        <option value="">Loading languages...</option>
                    </select>
                </div>

                <button class="btn" onclick="cloneWithExistingReference()">Clone Voice</button>
            </div>

            <!-- Upload Reference Tab -->
            <div id="upload-tab" class="tab-content">
                <div class="form-group">
                    <label>Reference Audio Source:</label>
                    <div class="audio-upload-tabs">
                        <div class="tab active" onclick="switchAudioSource('file')">Upload File</div>
                        <div class="tab" onclick="switchAudioSource('record')">Record Audio</div>
                        <div class="tab" onclick="switchAudioSource('youtube')">YouTube</div>
                    </div>
                </div>

                <!-- File Upload Section -->
                <div id="file-source" class="tab-content active">
                    <div class="form-group">
                        <label for="reference-file">Reference Audio File:</label>
                        <input type="file" id="reference-file" accept="audio/*" required>
                    </div>
                </div>

                <!-- Recording Section -->
                <div id="record-source" class="tab-content">
                    <div class="form-group">
                        <label>Record Reference Audio:</label>
                        <div class="recording-area">
                            <button id="record-btn" class="btn" onclick="toggleRecording()">Start Recording</button>
                            <button id="stop-btn" class="btn" onclick="stopRecording()" style="display: none; margin-left: 10px;">Stop Recording</button>
                            <p id="recording-status" style="margin-top: 15px; color: var(--accent); font-weight: 600;"></p>
                        </div>
                        <audio id="recorded-audio" controls class="audio-player" style="display: none;"></audio>
                    </div>
                </div>

                <!-- YouTube Section -->
                <div id="youtube-source" class="tab-content">
                    <div class="form-group">
                        <label for="youtube-url">YouTube Video URL:</label>
                        <input type="text" id="youtube-url" placeholder="https://www.youtube.com/watch?v=...">
                    </div>
                    <div class="form-group">
                        <label for="youtube-name">Reference Name (optional):</label>
                        <input type="text" id="youtube-name" placeholder="Enter a name for this reference audio...">
                    </div>
                </div>

                <div class="form-group">
                    <label for="text-upload">Text to Generate:</label>
                    <textarea id="text-upload" placeholder="Enter the text you want to generate in the cloned voice...">Hello, this is a test of the voice cloning system. How does it sound?</textarea>
                </div>

                <div class="form-group">
                    <label for="language-upload">Language:</label>
                    <select id="language-upload">
                        <option value="">Loading languages...</option>
                    </select>
                </div>

                <button class="btn" onclick="cloneWithUpload()">Upload & Clone</button>
            </div>

            <!-- Multi-Speaker Tab -->
            <div id="multispeaker-tab" class="tab-content">
                <div class="form-group">
                    <p style="color: var(--text-secondary); margin-bottom: 16px;">
                        Create a conversation or dialogue with multiple speakers. Each segment will be generated with its own reference voice and concatenated in sequence.
                    </p>
                </div>

                <div id="speaker-segments-container">
                    <!-- Speaker segments will be added here dynamically -->
                </div>

                <div class="form-group" style="display: flex; gap: 12px; margin-top: 16px;">
                    <button class="btn" onclick="addSpeakerSegment()" style="background: var(--accent);">+ Add Segment</button>
                    <button class="btn" onclick="cloneMultiSpeaker()">Generate Multi-Speaker Audio</button>
                </div>
            </div>
        </div>

        <!-- Progress Section -->
        <div id="progress-section" class="card hidden">
            <h3>Processing...</h3>
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <p id="progress-text">Initializing voice cloner...</p>
            <button id="cancel-btn" class="btn" onclick="cancelGeneration()" style="background: #dc3545; margin-top: 15px;">Cancel Generation</button>
        </div>

        <!-- Result Section -->
        <div id="result-section" class="card hidden">
            <h3>Voice Cloning Complete!</h3>
            <audio controls class="audio-player" id="result-audio">
                Your browser does not support the audio element.
            </audio>
            <br><br>
            <a href="#" id="download-link" class="btn" download>Download Audio</a>
        </div>

        <!-- Error Section -->
        <div id="error-section" class="card error hidden">
            <h3>Error</h3>
            <p id="error-message"></p>
        </div>

        <!-- Generated Audios Section -->
            <div class="card">
                <h3>Generated Audios</h3>
                <div id="generated-audios-list">
                    <p>No generated audios found. Create your first voice clone!</p>
                </div>
            </div>
        </div>

        <!-- Links Section -->
        <div class="card links-section">
            <h3 style="margin-bottom: 16px;">Support & More</h3>
            <div style="display: flex; justify-content: center; gap: 24px; flex-wrap: wrap;">
                <a href="https://github.com/AfkaraLP/qwen3-tts-webui" target="_blank" rel="noopener noreferrer">
                    <img src="/static/github-142-svgrepo-com.svg" alt="GitHub" width="20" height="20">
                    View on GitHub
                </a>
                <a href="https://ko-fi.com/afkaralp" target="_blank" rel="noopener noreferrer">
                    <img src="/static/kofi-svgrepo-com.svg" alt="Ko-fi" width="20" height="20">
                    Support on Ko-fi
                </a>
            </div>
        </div>
    </div>

    <script>
        let selectedReferenceId = null;
        let currentTaskId = null;
        let progressInterval = null;
        let mediaRecorder = null;
        let audioChunks = [];
        let recordedBlob = null;
        let currentAudioSource = 'file';
        let referencesData = {};

        // Theme toggle functionality
        function toggleTheme() {
            const html = document.documentElement;
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            updateThemeIcon(newTheme);
        }

        function updateThemeIcon(theme) {
            const themeIcon = document.getElementById('theme-icon');
            if (theme === 'dark') {
                themeIcon.innerHTML = '&#9788;'; // Sun symbol
            } else {
                themeIcon.innerHTML = '&#9790;'; // Moon symbol
            }
        }

        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const theme = savedTheme || (prefersDark ? 'dark' : 'light');
            
            document.documentElement.setAttribute('data-theme', theme);
            updateThemeIcon(theme);
        }

        // Initialize theme immediately
        initializeTheme();

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            loadReferences();
            loadLanguages();
            loadGeneratedAudios();
        });

        function switchTab(tab) {
            // Update tab buttons
            document.querySelectorAll('.tabs .tab').forEach(t => t.classList.remove('active'));
            const tabIndex = tab === 'existing' ? 1 : tab === 'upload' ? 2 : 3;
            document.querySelector(`.tabs .tab:nth-child(${tabIndex})`).classList.add('active');
            
            // Update tab content
            document.querySelectorAll('.card > .tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`${tab}-tab`).classList.add('active');
            
            // Initialize multi-speaker tab if switching to it for the first time
            if (tab === 'multispeaker') {
                initializeMultiSpeakerTab();
            }
            
            // Hide other sections
            hideAllSections();
        }

        function switchAudioSource(source) {
            currentAudioSource = source;
            
            // Update tab buttons in upload section
            const uploadTabs = document.querySelectorAll('.audio-upload-tabs .tab');
            uploadTabs.forEach(t => t.classList.remove('active'));
            const tabIndex = source === 'file' ? 0 : source === 'record' ? 1 : 2;
            uploadTabs[tabIndex].classList.add('active');
            
            // Update tab content
            document.querySelectorAll('#upload-tab .tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`${source}-source`).classList.add('active');
        }

        function hideAllSections() {
            document.getElementById('progress-section').classList.add('hidden');
            document.getElementById('result-section').classList.add('hidden');
            document.getElementById('error-section').classList.add('hidden');
        }

        async function loadReferences() {
            try {
                const response = await fetch('/references');
                const references = await response.json();
                
                const selectElement = document.getElementById('reference-select');
                
                // Clear existing options except the default one
                selectElement.innerHTML = '<option value="">-- Choose a reference audio --</option>';
                
                if (references.length === 0) {
                    selectElement.innerHTML = '<option value="">No reference audios found. Upload one first!</option>';
                    return;
                }
                
                references.forEach(ref => {
                    const option = document.createElement('option');
                    option.value = ref.id;
                    option.textContent = ref.name || ref.original_name;
                    selectElement.appendChild(option);
                });
                
                // Store references for preview functionality
                window.availableReferences = references;
                
                // Store references data for rename functionality
                referencesData = {};
                references.forEach(ref => {
                    referencesData[ref.id] = ref;
                });
                
            } catch (error) {
                console.error('Error loading references:', error);
                showError('Failed to load reference audios');
            }
        }

        async function loadLanguages() {
            try {
                const response = await fetch('/languages');
                const data = await response.json();
                
                const languages = data.languages;
                
                // Populate existing reference language dropdown
                const existingSelect = document.getElementById('language-existing');
                existingSelect.innerHTML = '';
                languages.forEach(lang => {
                    const option = document.createElement('option');
                    option.value = lang;
                    option.textContent = lang.charAt(0).toUpperCase() + lang.slice(1);
                    if (lang === 'English') {
                        option.selected = true;
                    }
                    existingSelect.appendChild(option);
                });
                
                // Populate upload language dropdown
                const uploadSelect = document.getElementById('language-upload');
                uploadSelect.innerHTML = '';
                languages.forEach(lang => {
                    const option = document.createElement('option');
                    option.value = lang;
                    option.textContent = lang.charAt(0).toUpperCase() + lang.slice(1);
                    if (lang === 'English') {
                        option.selected = true;
                    }
                    uploadSelect.appendChild(option);
                });
                
            } catch (error) {
                console.error('Error loading languages:', error);
                showError('Failed to load languages');
            }
        }

        async function loadGeneratedAudios() {
            try {
                const response = await fetch('/generated');
                const generatedAudios = await response.json();
                
                const container = document.getElementById('generated-audios-list');
                
                if (generatedAudios.length === 0) {
                    container.innerHTML = '<p>No generated audios found. Create your first voice clone!</p>';
                    return;
                }
                
                container.innerHTML = '';
                generatedAudios.forEach(audio => {
                    const audioDiv = document.createElement('div');
                    audioDiv.className = 'generated-audio-item';
                    
                    const titleDiv = document.createElement('div');
                    titleDiv.className = 'generated-audio-title';
                    titleDiv.textContent = audio.generated_text.substring(0, 80) + (audio.generated_text.length > 80 ? '...' : '');
                    
                    const infoDiv = document.createElement('div');
                    infoDiv.className = 'generated-audio-meta';
                    infoDiv.innerHTML = `
                        Reference: ${audio.ref_audio_name}<br>
                        Created: ${new Date(parseFloat(audio.created_at) * 1000).toLocaleString()}
                    `;
                    
                    const controlsDiv = document.createElement('div');
                    controlsDiv.className = 'generated-audio-controls';
                    
                    const audioControl = document.createElement('audio');
                    audioControl.controls = true;
                    audioControl.src = `/tasks/${audio.id}/audio`;
                    
                    const downloadBtn = document.createElement('a');
                    downloadBtn.href = `/tasks/${audio.id}/audio`;
                    downloadBtn.download = `cloned_voice_${audio.id}.wav`;
                    downloadBtn.className = 'btn';
                    downloadBtn.textContent = 'Download';
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'btn btn-danger';
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.onclick = () => deleteGeneratedAudio(audio.id);
                    
                    controlsDiv.appendChild(audioControl);
                    controlsDiv.appendChild(downloadBtn);
                    controlsDiv.appendChild(deleteBtn);
                    
                    audioDiv.appendChild(titleDiv);
                    audioDiv.appendChild(infoDiv);
                    audioDiv.appendChild(controlsDiv);
                    container.appendChild(audioDiv);
                });
                
            } catch (error) {
                console.error('Error loading generated audios:', error);
                showError('Failed to load generated audios');
            }
        }

        async function deleteGeneratedAudio(audioId) {
            try {
                const response = await fetch(`/generated/${audioId}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    loadGeneratedAudios();
                } else {
                    const error = await response.json();
                    showError(error.detail || 'Failed to delete audio');
                }
            } catch (error) {
                console.error('Error deleting generated audio:', error);
                showError('Failed to delete audio');
            }
        }

        function selectReferenceFromDropdown() {
            const selectElement = document.getElementById('reference-select');
            selectedReferenceId = selectElement.value;
            
            const previewDiv = document.getElementById('reference-preview');
            const previewAudio = document.getElementById('preview-audio');
            const renameDiv = document.getElementById('reference-rename');
            const nameInput = document.getElementById('reference-name-input');
            
            if (selectedReferenceId) {
                // Show preview and load audio
                previewDiv.style.display = 'block';
                previewAudio.src = `/references/${selectedReferenceId}/audio`;
                
                // Show rename section and populate with current name
                renameDiv.style.display = 'block';
                const refData = referencesData[selectedReferenceId];
                nameInput.value = refData.name || refData.original_name;
            } else {
                // Hide preview and rename sections
                previewDiv.style.display = 'none';
                renameDiv.style.display = 'none';
                previewAudio.src = '';
            }
        }

        async function renameReference() {
            if (!selectedReferenceId) {
                showError('Please select a reference audio first');
                return;
            }
            
            const nameInput = document.getElementById('reference-name-input');
            const newName = nameInput.value.trim();
            
            if (!newName) {
                showError('Please enter a name for the reference');
                return;
            }
            
            try {
                const response = await fetch(`/references/${selectedReferenceId}/name`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ name: newName })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to rename reference');
                }
                
                const result = await response.json();
                
                // Update the stored data
                if (referencesData[selectedReferenceId]) {
                    referencesData[selectedReferenceId].name = newName;
                }
                
                // Update the dropdown display
                const selectElement = document.getElementById('reference-select');
                const option = selectElement.querySelector(`option[value="${selectedReferenceId}"]`);
                if (option) {
                    option.textContent = newName;
                }
                
                showSuccess('Reference renamed successfully');
                
            } catch (error) {
                console.error('Error renaming reference:', error);
                showError('Failed to rename reference');
            }
        }

        async function cloneWithExistingReference() {
            if (!selectedReferenceId) {
                showError('Please select a reference audio from the dropdown');
                return;
            }
            
            const text = document.getElementById('text-existing').value;
            const language = document.getElementById('language-existing').value;
            
            if (!text.trim()) {
                showError('Please enter text to generate');
                return;
            }
            
            await performCloning('/clone', {
                text: text,
                ref_audio_id: selectedReferenceId,
                language: language
            });
        }

        async function cloneWithUpload() {
            const text = document.getElementById('text-upload').value;
            const language = document.getElementById('language-upload').value;
            
            if (!text.trim()) {
                showError('Please enter text to generate');
                return;
            }
            
            if (currentAudioSource === 'youtube') {
                const youtubeUrl = document.getElementById('youtube-url').value;
                const youtubeName = document.getElementById('youtube-name').value;
                
                if (!youtubeUrl.trim()) {
                    showError('Please enter a YouTube URL');
                    return;
                }
                
                await performCloning('/clone-with-youtube', {
                    youtube_url: youtubeUrl,
                    text: text,
                    language: language,
                    name: youtubeName || undefined
                });
            } else {
                let file;
                
                if (currentAudioSource === 'file') {
                    const fileInput = document.getElementById('reference-file');
                    file = fileInput.files[0];
                    
                    if (!file) {
                        showError('Please select a reference audio file');
                        return;
                    }
                } else { // record
                    if (!recordedBlob) {
                        showError('Please record audio first');
                        return;
                    }
                    // Determine file extension based on MIME type
                    const mimeToExt = {
                        'audio/webm': 'webm',
                        'audio/webm;codecs=opus': 'webm',
                        'audio/ogg': 'ogg',
                        'audio/ogg;codecs=opus': 'ogg',
                        'audio/mp4': 'mp4',
                        'audio/mpeg': 'mp3',
                        'audio/wav': 'wav'
                    };
                    const ext = mimeToExt[recordedBlob.type] || 'webm';
                    file = new File([recordedBlob], `recorded_audio.${ext}`, { type: recordedBlob.type });
                }
                
                const formData = new FormData();
                formData.append('file', file);
                formData.append('text', text);
                formData.append('language', language);
                
                await performCloning('/clone-with-upload', formData, true);
            }
        }

        async function performCloning(endpoint, data, isFormData = false) {
            hideAllSections();
            
            const progressSection = document.getElementById('progress-section');
            progressSection.classList.remove('hidden');
            
            try {
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: isFormData ? {} : { 'Content-Type': 'application/json' },
                    body: isFormData ? data : JSON.stringify(data)
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || 'Failed to start cloning');
                }
                
                const result = await response.json();
                currentTaskId = result.task_id;
                
                // Start polling for progress
                startProgressPolling();
                
            } catch (error) {
                console.error('Error starting cloning:', error);
                showError(error.message);
            }
        }

        function startProgressPolling() {
            if (progressInterval) {
                clearInterval(progressInterval);
            }
            
            progressInterval = setInterval(async () => {
                try {
                    const response = await fetch(`/tasks/${currentTaskId}`);
                    const task = await response.json();
                    
                    updateProgress(task);
                    
                    if (task.status === 'completed') {
                        clearInterval(progressInterval);
                        showResult(task.output_path);
                        loadGeneratedAudios(); // Refresh the generated audios list
                    } else if (task.status === 'failed') {
                        clearInterval(progressInterval);
                        hideAllSections();
                        showError(task.error || 'Cloning failed');
                    }
                } catch (error) {
                    console.error('Error polling task status:', error);
                }
            }, 1000);
        }

        function updateProgress(task) {
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            
            const progress = task.progress || 0;
            progressFill.style.width = `${progress}%`;
            
            if (task.status === 'processing') {
                if (progress < 25) {
                    progressText.textContent = 'Initializing voice cloner...';
                } else if (progress < 50) {
                    progressText.textContent = 'Processing reference audio...';
                } else if (progress < 75) {
                    progressText.textContent = 'Generating cloned voice...';
                } else {
                    progressText.textContent = 'Finalizing audio...';
                }
            } else if (task.status === 'cancelled') {
                progressText.textContent = 'Generation cancelled';
                clearInterval(progressInterval);
                hideAllSections();
                document.getElementById('error-section').classList.remove('hidden');
                document.getElementById('error-message').textContent = 'Generation was cancelled';
            }
        }

        function showResult(outputPath) {
            hideAllSections();
            
            const resultSection = document.getElementById('result-section');
            const resultAudio = document.getElementById('result-audio');
            const downloadLink = document.getElementById('download-link');
            
            resultAudio.src = `/tasks/${currentTaskId}/audio`;
            downloadLink.href = `/tasks/${currentTaskId}/audio`;
            
            resultSection.classList.remove('hidden');
            
            // Refresh references to potentially include the new one
            loadReferences();
        }

        function showToast(message, type = 'error', duration = 5000) {
            const container = document.getElementById('toast-container');
            
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.textContent = message;
            
            container.appendChild(toast);
            
            // Slide out and remove after duration
            setTimeout(() => {
                toast.classList.add('slide-out');
                // Remove from DOM after animation completes
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, duration);
        }

        function showError(message) {
            showToast(message, 'error', 5000);
        }

        function showSuccess(message) {
            showToast(message, 'success', 3000);
        }

        async function cancelGeneration() {
            if (!currentTaskId) {
                return;
            }
            
            try {
                const response = await fetch(`/tasks/${currentTaskId}/cancel`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                // Always stop the animation and hide progress section when cancel is clicked
                clearInterval(progressInterval);
                hideAllSections();
                
                if (response.ok) {
                    currentTaskId = null;
                    showSuccess('Generation cancelled');
                } else {
                    // Task may have already completed or failed, still hide the progress
                    const error = await response.json();
                    currentTaskId = null;
                    // Don't show error if task already finished - just a minor notification
                    console.log('Cancel response:', error.detail);
                }
            } catch (error) {
                // Even on network error, stop the animation
                clearInterval(progressInterval);
                hideAllSections();
                console.error('Error cancelling task:', error);
                showError('Failed to cancel generation');
            }
        }

        async function toggleRecording() {
            try {
                // Check if mediaDevices API is available (requires secure context)
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                    if (!isLocalhost && window.location.protocol !== 'https:') {
                        showError('Microphone access requires HTTPS. Please access this page via localhost or HTTPS.');
                    } else {
                        showError('Your browser does not support audio recording.');
                    }
                    return;
                }

                // Use more flexible audio constraints for better browser compatibility
                const audioConstraints = {
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                };

                let stream;
                try {
                    stream = await navigator.mediaDevices.getUserMedia(audioConstraints);
                } catch (constraintError) {
                    // If constraints fail, try with simple audio: true
                    console.warn('Detailed constraints failed, trying simple constraints:', constraintError);
                    stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                }
                
                // Determine the best supported MIME type for recording
                // Firefox prefers ogg, Chrome/Safari prefer webm
                let mimeType = '';
                const mimeTypes = [
                    'audio/ogg;codecs=opus',  // Firefox preferred
                    'audio/webm;codecs=opus', // Chrome preferred
                    'audio/ogg',
                    'audio/webm',
                    'audio/mp4',
                    'audio/mpeg'
                ];
                
                for (const type of mimeTypes) {
                    if (MediaRecorder.isTypeSupported(type)) {
                        mimeType = type;
                        break;
                    }
                }
                
                // Create MediaRecorder with or without mimeType option
                const options = mimeType ? { mimeType } : {};
                mediaRecorder = new MediaRecorder(stream, options);
                audioChunks = [];

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    // Use the actual MIME type from the MediaRecorder
                    const actualMimeType = mediaRecorder.mimeType || mimeType || 'audio/ogg';
                    recordedBlob = new Blob(audioChunks, { type: actualMimeType });
                    const audioUrl = URL.createObjectURL(recordedBlob);
                    const recordedAudio = document.getElementById('recorded-audio');
                    recordedAudio.src = audioUrl;
                    recordedAudio.style.display = 'block';
                };

                mediaRecorder.start();
                
                document.getElementById('record-btn').style.display = 'none';
                document.getElementById('stop-btn').style.display = 'inline-block';
                document.getElementById('recording-status').textContent = 'Recording... Click Stop when finished.';
                
            } catch (error) {
                console.error('Error accessing microphone:', error);
                console.error('Error name:', error.name);
                console.error('Error message:', error.message);
                
                // Provide more specific error messages
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    showError('Microphone permission denied. Please allow microphone access in your browser settings and reload the page.');
                } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                    // Additional help for Firefox on macOS
                    showError('No microphone found. On macOS, please check: System Preferences > Security & Privacy > Privacy > Microphone, and ensure Firefox is allowed.');
                } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                    showError('Microphone is in use by another application. Please close other apps using the microphone.');
                } else if (error.name === 'OverconstrainedError') {
                    showError('Could not satisfy audio constraints. Please try a different microphone.');
                } else if (error.name === 'SecurityError') {
                    showError('Microphone access blocked due to security policy. Please use HTTPS or localhost.');
                } else if (error.name === 'AbortError') {
                    showError('Microphone access was aborted. Please try again.');
                } else {
                    showError(`Could not access microphone: ${error.message || error.name || 'Unknown error'}. Check browser console for details.`);
                }
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                
                document.getElementById('record-btn').style.display = 'inline-block';
                document.getElementById('stop-btn').style.display = 'none';
                document.getElementById('recording-status').textContent = 'Recording complete! Audio ready for upload.';
            }
        }

        // ==========================================
        // Multi-Speaker Functionality
        // ==========================================
        
        let speakerSegmentCount = 0;
        let multiSpeakerInitialized = false;

        function initializeMultiSpeakerTab() {
            if (multiSpeakerInitialized) return;
            
            // Add two initial segments
            addSpeakerSegment();
            addSpeakerSegment();
            
            multiSpeakerInitialized = true;
        }

        function addSpeakerSegment() {
            speakerSegmentCount++;
            const segmentId = speakerSegmentCount;
            const container = document.getElementById('speaker-segments-container');
            
            const segmentDiv = document.createElement('div');
            segmentDiv.className = 'speaker-segment';
            segmentDiv.id = `segment-${segmentId}`;
            segmentDiv.innerHTML = `
                <div class="speaker-segment-header">
                    <span class="speaker-segment-title">Segment ${segmentId}</span>
                    <button class="speaker-segment-remove" onclick="removeSpeakerSegment(${segmentId})">Remove</button>
                </div>
                <div class="segment-row">
                    <div class="form-group">
                        <label for="segment-${segmentId}-speaker">Reference Speaker:</label>
                        <select id="segment-${segmentId}-speaker" class="segment-speaker-select">
                            <option value="">-- Choose a speaker --</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="segment-${segmentId}-language">Language:</label>
                        <select id="segment-${segmentId}-language" class="segment-language-select">
                            <option value="auto">Auto</option>
                        </select>
                    </div>
                </div>
                <div class="form-group">
                    <label for="segment-${segmentId}-text">Text to Generate:</label>
                    <textarea id="segment-${segmentId}-text" class="segment-text" placeholder="Enter the text for this speaker..." rows="2"></textarea>
                </div>
            `;
            
            container.appendChild(segmentDiv);
            
            // Populate the speaker dropdown
            populateSegmentSpeakerDropdown(segmentId);
            
            // Populate the language dropdown
            populateSegmentLanguageDropdown(segmentId);
            
            updateSegmentNumbers();
        }

        function removeSpeakerSegment(segmentId) {
            const segment = document.getElementById(`segment-${segmentId}`);
            if (segment) {
                segment.remove();
                updateSegmentNumbers();
            }
        }

        function updateSegmentNumbers() {
            const segments = document.querySelectorAll('.speaker-segment');
            segments.forEach((segment, index) => {
                const title = segment.querySelector('.speaker-segment-title');
                if (title) {
                    title.textContent = `Segment ${index + 1}`;
                }
            });
        }

        function populateSegmentSpeakerDropdown(segmentId) {
            const select = document.getElementById(`segment-${segmentId}-speaker`);
            if (!select || !window.availableReferences) return;
            
            // Preserve the currently selected value
            const currentValue = select.value;
            
            select.innerHTML = '<option value="">-- Choose a speaker --</option>';
            window.availableReferences.forEach(ref => {
                const option = document.createElement('option');
                option.value = ref.id;
                option.textContent = ref.name || ref.original_name;
                select.appendChild(option);
            });
            
            // Restore the previously selected value if it still exists
            if (currentValue) {
                select.value = currentValue;
            }
        }

        function populateSegmentLanguageDropdown(segmentId) {
            const select = document.getElementById(`segment-${segmentId}-language`);
            if (!select) return;
            
            // Try to get languages from the existing dropdown
            const existingLanguageSelect = document.getElementById('language-existing');
            if (existingLanguageSelect && existingLanguageSelect.options.length > 0) {
                select.innerHTML = '';
                for (const option of existingLanguageSelect.options) {
                    const newOption = document.createElement('option');
                    newOption.value = option.value;
                    newOption.textContent = option.textContent;
                    if (option.value === 'English') {
                        newOption.selected = true;
                    }
                    select.appendChild(newOption);
                }
            }
        }

        function getMultiSpeakerSegments() {
            const segments = [];
            const segmentElements = document.querySelectorAll('.speaker-segment');
            
            segmentElements.forEach((element, index) => {
                const speakerSelect = element.querySelector('.segment-speaker-select');
                const languageSelect = element.querySelector('.segment-language-select');
                const textArea = element.querySelector('.segment-text');
                
                segments.push({
                    text: textArea ? textArea.value : '',
                    ref_audio_id: speakerSelect ? speakerSelect.value : '',
                    language: languageSelect ? languageSelect.value : 'auto'
                });
            });
            
            return segments;
        }

        async function cloneMultiSpeaker() {
            const segments = getMultiSpeakerSegments();
            
            // Validate segments
            if (segments.length === 0) {
                showError('Please add at least one segment');
                return;
            }
            
            for (let i = 0; i < segments.length; i++) {
                if (!segments[i].ref_audio_id) {
                    showError(`Segment ${i + 1}: Please select a reference speaker`);
                    return;
                }
                if (!segments[i].text.trim()) {
                    showError(`Segment ${i + 1}: Please enter text to generate`);
                    return;
                }
            }
            
            await performCloning('/clone-multi-speaker', { segments: segments });
        }

        // Update progress display for multi-speaker tasks
        function updateProgressMultiSpeaker(task) {
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            
            const progress = task.progress || 0;
            progressFill.style.width = `${progress}%`;
            
            if (task.is_multi_speaker && task.total_segments) {
                const currentSeg = task.current_segment || 0;
                const totalSeg = task.total_segments;
                
                if (progress < 5) {
                    progressText.textContent = 'Initializing multi-speaker generation...';
                } else if (progress < 90) {
                    progressText.textContent = `Generating segment ${currentSeg} of ${totalSeg}...`;
                } else if (progress < 95) {
                    progressText.textContent = 'Concatenating audio segments...';
                } else {
                    progressText.textContent = 'Finalizing audio...';
                }
            }
        }

        // Override the existing updateProgress to handle multi-speaker
        const originalUpdateProgress = updateProgress;
        updateProgress = function(task) {
            if (task.is_multi_speaker) {
                updateProgressMultiSpeaker(task);
            } else {
                originalUpdateProgress(task);
            }
            
            // Handle cancellation for both types
            if (task.status === 'cancelled') {
                const progressText = document.getElementById('progress-text');
                progressText.textContent = 'Generation cancelled';
                clearInterval(progressInterval);
                hideAllSections();
                document.getElementById('error-section').classList.remove('hidden');
                document.getElementById('error-message').textContent = 'Generation was cancelled';
            }
        };

        // Refresh segment dropdowns when references are loaded
        const originalLoadReferences = loadReferences;
        loadReferences = async function() {
            await originalLoadReferences();
            
            // Update all multi-speaker segment dropdowns
            document.querySelectorAll('.speaker-segment').forEach(segment => {
                const segmentId = segment.id.replace('segment-', '');
                populateSegmentSpeakerDropdown(segmentId);
            });
        };
    </script>
</body>
</html>
